# ABI compatibility check for x86 CPUID data
#
# Copyright (c) 2018 Red Hat, Inc.
#
# Author:
#  Eduardo Habkost <ehabkost@redhat.com>
#
# This work is licensed under the terms of the GNU GPL, version 2 or
# later.  See the COPYING file in the top-level directory.

import logging
import pathlib
import os
import tempfile

from avocado_qemu import Test

MY_DIR = pathlib.Path(__file__).parent

class GuestABIX86CPUID(Test):
    maxDiff = None

    def setUp(self):
        super(GuestABIX86CPUID, self).setUp()

        self.machine = self.params.get('machine')
        if not self.machine:
            self.cancel("Test case requires machine parameter")
        self.vm.set_machine(self.machine)

        self.cpu = self.params.get('cpu')
        if not self.cpu:
            self.cancel("Test case requires cpu parameter")
        self.vm.add_args('-cpu', '%s,check=off,enforce=off,x-force-features=on' % (self.cpu))

    def machine_name(self):
        # type: () -> Optional[str]
        """Returns actual machine type being used"""
        if self.machine:
            #TODO: return full name if self.machine is an alias like "pc" or "q35"
            return self.machine

        default_machine = [m['name'] for m in self.vm.command('query-machines') if m.get('is-default')]
        if not default_machine:
            self.cancel('No default machine-type found')

        return default_machine[0]

    def cpu_model(self):
        """Returns actual CPU model being run"""
        # If the CPU model is explicitly configured, this is trivial:
        if self.cpu:
            return self.cpu

        # If the CPU model name is omitted, try to find out using
        # the data QEMU provides via QMP:
        # * query-cpus gives us qom_path
        # * qom-get property=type gives us the QOM type
        # * query-cpu-definitions gives us the CPU model namne corresponding to
        #   QOM type
        cpu_defs = self.vm.command('query-cpu-definitions')
        cpu_path = self.vm.command('query-cpus')[0].get('qom_path')
        cpu_type = self.vm.command('qom-get', path=cpu_path, property='type')
        cpu_model = [c['name'] for c in cpu_defs if c.get('typename') == cpu_type]
        return cpu_model[0]

    def data_dir(self):
        """Return path for data directory for this test case

        Files will be stored at `guest_abi.data/<machine>/<cpu>`.
        """
        return MY_DIR / 'guest_abi.data' / self.machine_name() / self.cpu_model()

    def data_file_path(self, filename):
        """Return path for data file

        We could be using Avocado's `TestCase.get_data()` for
        this, but the filenames generated by Avocado are just
        hashes of the variant parameters, making the file path
        less obvious for people looking at the data directory.
        """
        return self.data_dir() / filename

    def force_data_update(self):
        """Return True if forcing data file update"""
        update_data = self.params.get('force_data_update')
        return update_data and update_data.lower() not in ['0', 'no']

    def data_file_exists(self, filename):
        """Return True if data file exists or if forcing data file update"""
        return self.data_file_path(filename).exists() or self.force_data_update()

    def data_file_should_exist(self, filename):
        """Cancel test case if data file doesn't exist and is not being updated
        """
        if not self.data_file_exists(filename):
            self.cancel("No reference file at %s" % (self.data_file_path(filename)))

    def open_data_file(self, filename, mode):
        return open(self.data_file_path(filename), mode)

    def update_data_file(self, filename, data, mode='b'):
        os.makedirs(self.data_file_path(filename).parent, exist_ok=True)
        with self.open_data_file(filename, 'w'+mode) as f:
            f.write(data)

    def assert_equals_file(self, filename, data, mode='b'):
        """Check if `data` matches contents of `filename`

        :param mode: File mode for `open()`` ('t' or 'b')
        """
        self.data_file_should_exist(filename)
        if self.force_data_update():
            self.update_data_file(filename, data, mode)
        ref = self.open_data_file(filename, 'r'+mode).read()
        self.assertEquals(ref, data)

    def test(self):
        self.data_file_should_exist('cpuid-dump.txt')
        dumpfile = tempfile.NamedTemporaryFile()
        kernelpath = MY_DIR / 'cpuid-dump-kernel/cpuid_dump_kernel.bin'
        if not kernelpath.exists():
            self.cancel("cpuid_dump_kernel.bin unavailable")
        self.vm.add_args('-kernel', str(kernelpath))
        self.vm.add_args('-serial', 'file:' + dumpfile.name)
        self.vm.add_args('-device', 'isa-debug-exit')
        self.vm.launch()
        self.vm.wait()
        dump = open(dumpfile.name, 'rt').read()

        self.assert_equals_file('cpuid-dump.txt', dump, mode='t')
